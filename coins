import cv2
import numpy as np
import matplotlib.pyplot as plt
import mahotas

def show_image(win_name, img):
    cv2.imshow(win_name, img)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

image = cv2.imread("forint_4.jpg", cv2.IMREAD_COLOR)

height, width = image.shape[:2]
new_width = 600
r = new_width/width
image = cv2.resize(image, (new_width, int(height * r)))

gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
gray = gray.astype(np.float32) / 255
log_img = np.log1p(gray)
fft = np.fft.fft2(log_img)
fft_shift = np.fft.fftshift(fft)


# 3. Magnitúdó (abszolút érték)
magnitude = np.abs(fft_shift)

# 4. Logaritmikus skálázás a jobb láthatóság érdekében
magnitude_log = np.log(1 + magnitude)

# 5. Normalizálás 0-255 közé és átalakítás uint8 típusra
magnitude_img = cv2.normalize(magnitude_log, None, 0, 255, cv2.NORM_MINMAX)
magnitude_img = magnitude_img.astype(np.uint8)

# 6. Megjelenítés OpenCV-vel
cv2.imshow("FFT Magnitude Spectrum", magnitude_img)
cv2.waitKey(0)
cv2.destroyAllWindows()


rows, cols = gray.shape
crow, ccol = rows//2, cols//2

Y, X = np.ogrid[:rows, :cols]
D = np.sqrt((X - ccol)**2 + (Y - crow)**2)
D0 = 170   # cutoff crow 190
n = 3      # 3 order
gammaH = 1.9 #  1.9
gammaL = 0.3 # 0.15

H = (gammaH - gammaL) * (1 - np.exp(- (D**2) / (2 * (D0**2)))) + gammaL

cv2.imshow("Mask", H)

filtered = fft_shift * H
img_out = np.fft.ifft2(np.fft.ifftshift(filtered))
img_out = np.exp(np.real(img_out)) - 1
img_out = cv2.normalize(img_out, None, 0, 255, cv2.NORM_MINMAX)
img_out = img_out.astype(np.uint8)

img_out = np.power(img_out / 255.0, 0.8) * 255
img_out = img_out.astype(np.uint8)

show_image("Homomorphic filter eredmeny", img_out)


guided = cv2.ximgproc.guidedFilter(guide=img_out, src=img_out, radius=8, eps=50)
show_image("Guided Filter utan", guided)

clahe = cv2.createCLAHE(clipLimit=2, tileGridSize=(8,8))
img_clahe = clahe.apply(guided)

show_image("Clache utan", img_clahe)

# --- 4. Zajcsökkentés (Gaussian simítás) ---
# blur = cv2.GaussianBlur(img_clahe, (7,7), 0) # 5,5
blur = cv2.bilateralFilter(img_clahe, 11, 35, 95)


show_image("Bilateral Filter utan", blur)

# --- 5. Adaptív küszöbölés ---
thresh = cv2.adaptiveThreshold(
    blur, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
    cv2.THRESH_BINARY_INV, 51, 4     # 39 5
)

mask = mahotas.morph.close(thresh, np.ones((25,25))) # 7,7
mask = mahotas.morph.open(mask, np.ones((3,3))) # 3,3

show_image("Filtered mask", mask)

height, width = image.shape[:2]
new_width = 600
r = new_width/width
coins = cv2.resize(image, (new_width, int(height * r)))
img_norm = cv2.resize(img_out, (new_width, int(height * r)))

mask_smooth = cv2.medianBlur(mask, 15)
_, mask_smooth = cv2.threshold(mask_smooth, 127, 255, cv2.THRESH_BINARY)

mask_closed = cv2.morphologyEx(mask, cv2.MORPH_CLOSE,
                               cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (11,11)))
show_image("Mask Closed", mask_closed)
canny = cv2.Canny(mask_closed, 40, 120)
show_image("Canny",canny)

filtered_contours = []
cnts, hierarchy  = cv2.findContours(canny, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
for contour in cnts:
    area = cv2.contourArea(contour)
    perimeter = cv2.arcLength(contour, True)

    if perimeter == 0:  # védelem a 0 osztás ellen
        continue

    circularity = 4 * np.pi * (area / (perimeter * perimeter))
    print(circularity)

    if 0.1 < circularity < 1.9 and area > 5000:
        filtered_contours.append(contour)

    else:
        pass
        # print("Nem kör. Circularity:", circularity)

print(len(filtered_contours))
# coins = resized_image.copy() # findContours function is destructive to the image you pass in. If you intend using that image later on in your code, it’s best to make a copy of it,
cv2.drawContours(coins, filtered_contours, -1, (0, 255, 0), 2) #  By specifying a negative value of −1, we are indicating that we want to draw all of the contours.
show_image("Contour", coins)
